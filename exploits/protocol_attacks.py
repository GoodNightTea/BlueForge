
# exploits/protocol_attacks.py - Advanced BLE Protocol Exploitation Engine
import asyncio
import struct
import time
import secrets
from typing import Dict, List, Optional, Any, Tuple, Union, Callable
from dataclasses import dataclass, field
from enum import Enum
from bleak import BleakClient
from bleak.backends.characteristic import BleakGATTCharacteristic
from security.vurnerability_scanner import VulnerabilityFinding, VulnerabilityType
from utils.logging import get_logger

logger = get_logger(__name__)

class ProtocolLayer(Enum):
    """BLE protocol stack layers"""
    PHYSICAL = "physical"
    LINK_LAYER = "link_layer" 
    L2CAP = "l2cap"
    ATT = "att"
    GATT = "gatt"
    GAP = "gap"
    SMP = "smp"  # Security Manager Protocol
    APPLICATION = "application"

class AttackType(Enum):
    """Types of protocol attacks"""
    PAIRING_BYPASS = "pairing_bypass"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    ENCRYPTION_BYPASS = "encryption_bypass"
    INJECTION_ATTACK = "injection_attack"
    REPLAY_ATTACK = "replay_attack"
    DOWNGRADE_ATTACK = "downgrade_attack"
    STATE_CONFUSION = "state_confusion"
    RACE_CONDITION = "race_condition"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    SESSION_HIJACKING = "session_hijacking"
    MITM_ATTACK = "mitm_attack"
    DESYNCHRONIZATION = "desynchronization"

class AttackComplexity(Enum):
    """Attack complexity levels"""
    TRIVIAL = "trivial"        # Single packet
    SIMPLE = "simple"          # Few packets, basic timing
    MODERATE = "moderate"      # Multi-step, state management
    COMPLEX = "complex"        # Advanced timing, multiple protocols
    EXPERT = "expert"          # Requires deep protocol knowledge

@dataclass
class ProtocolState:
    """Represents current protocol state"""
    connection_state: str = "disconnected"
    pairing_state: str = "unpaired"
    encryption_enabled: bool = False
    authentication_level: int = 0
    bond_state: str = "unbonded"
    security_level: int = 1
    mtu_size: int = 23
    connection_interval: float = 0.0
    last_activity: float = 0.0
    active_procedures: List[str] = field(default_factory=list)

@dataclass
class AttackVector:
    """Specific protocol attack vector"""
    name: str
    attack_type: AttackType
    target_layer: ProtocolLayer
    complexity: AttackComplexity
    description: str
    prerequisites: List[str] = field(default_factory=list)
    attack_steps: List[Dict[str, Any]] = field(default_factory=list)
    success_indicators: List[str] = field(default_factory=list)
    reliability: float = 0.0
    stealth_level: int = 1  # 1-5, how detectable the attack is

@dataclass
class AttackResult:
    """Result of protocol attack execution"""
    attack_name: str
    attack_type: AttackType
    success: bool
    target_layer: ProtocolLayer
    execution_time: float
    steps_completed: int
    total_steps: int
    privileges_gained: List[str] = field(default_factory=list)
    data_extracted: Dict[str, Any] = field(default_factory=dict)
    persistence_achieved: bool = False
    detection_likelihood: str = "unknown"
    error_message: Optional[str] = None
    side_effects: List[str] = field(default_factory=list)

class ProtocolAttackEngine:
    """Advanced BLE protocol exploitation engine"""
    
    def __init__(self):
        self.logger = get_logger(f"{__name__}.ProtocolAttackEngine")
        
        # Protocol state tracking
        self.protocol_state = ProtocolState()
        
        # Attack vector library
        self.attack_vectors = self._initialize_attack_vectors()
        
        # Protocol constants and opcodes
        self.protocol_constants = self._initialize_protocol_constants()
        
        # State machine definitions
        self.state_machines = self._initialize_state_machines()
        
        # Attack session tracking
        self.active_attacks = {}
        self.attack_history = []
    
    def _initialize_attack_vectors(self) -> Dict[AttackType, List[AttackVector]]:
        """Initialize comprehensive attack vector library"""
        
        return {
            AttackType.PAIRING_BYPASS: [
                AttackVector(
                    name="Just Works Downgrade",
                    attack_type=AttackType.PAIRING_BYPASS,
                    target_layer=ProtocolLayer.SMP,
                    complexity=AttackComplexity.SIMPLE,
                    description="Force downgrade to Just Works pairing",
                    prerequisites=["unpaired_device", "pairing_initiation"],
                    attack_steps=[
                        {"action": "intercept_pairing_request", "timing": "immediate"},
                        {"action": "modify_io_capabilities", "params": {"io_cap": 0x03}},
                        {"action": "force_just_works", "timing": "on_pairing_response"}
                    ],
                    success_indicators=["pairing_complete", "no_authentication_required"],
                    reliability=0.8,
                    stealth_level=2
                ),
                
                AttackVector(
                    name="Pairing Method Confusion",
                    attack_type=AttackType.PAIRING_BYPASS,
                    target_layer=ProtocolLayer.SMP,
                    complexity=AttackComplexity.MODERATE,
                    description="Confuse pairing state machine with conflicting methods",
                    prerequisites=["pairing_in_progress"],
                    attack_steps=[
                        {"action": "send_conflicting_pairing_response", "timing": "immediate"},
                        {"action": "race_pairing_confirm", "timing": "0.1s"},
                        {"action": "inject_fake_random", "timing": "on_confirm"}
                    ],
                    success_indicators=["pairing_bypass", "elevated_privileges"],
                    reliability=0.6,
                    stealth_level=3
                )
            ],
            
            AttackType.AUTHENTICATION_BYPASS: [
                AttackVector(
                    name="ATT Authentication Bypass",
                    attack_type=AttackType.AUTHENTICATION_BYPASS,
                    target_layer=ProtocolLayer.ATT,
                    complexity=AttackComplexity.SIMPLE,
                    description="Bypass ATT-level authentication checks",
                    prerequisites=["connected_device", "secured_characteristics"],
                    attack_steps=[
                        {"action": "enumerate_characteristics", "timing": "immediate"},
                        {"action": "test_direct_access", "timing": "immediate"},
                        {"action": "send_unauthenticated_write", "timing": "immediate"}
                    ],
                    success_indicators=["write_success", "no_auth_error"],
                    reliability=0.7,
                    stealth_level=1
                ),
                
                AttackVector(
                    name="GATT Permission Escalation",
                    attack_type=AttackType.AUTHENTICATION_BYPASS,
                    target_layer=ProtocolLayer.GATT,
                    complexity=AttackComplexity.MODERATE,
                    description="Escalate GATT permissions through service confusion",
                    prerequisites=["gatt_services_available"],
                    attack_steps=[
                        {"action": "discover_service_hierarchy", "timing": "immediate"},
                        {"action": "identify_permission_boundaries", "timing": "immediate"},
                        {"action": "exploit_service_aliasing", "timing": "immediate"},
                        {"action": "access_restricted_characteristics", "timing": "immediate"}
                    ],
                    success_indicators=["restricted_access_granted", "privilege_escalation"],
                    reliability=0.5,
                    stealth_level=2
                )
            ],
            
            AttackType.INJECTION_ATTACK: [
                AttackVector(
                    name="ATT Command Injection",
                    attack_type=AttackType.INJECTION_ATTACK,
                    target_layer=ProtocolLayer.ATT,
                    complexity=AttackComplexity.MODERATE,
                    description="Inject malicious ATT commands in protocol flow",
                    prerequisites=["active_connection", "writable_characteristics"],
                    attack_steps=[
                        {"action": "analyze_att_flow", "timing": "immediate"},
                        {"action": "craft_injection_payload", "timing": "immediate"},
                        {"action": "inject_during_operation", "timing": "on_att_activity"},
                        {"action": "monitor_injection_effects", "timing": "post_injection"}
                    ],
                    success_indicators=["command_executed", "unexpected_response"],
                    reliability=0.6,
                    stealth_level=3
                ),
                
                AttackVector(
                    name="L2CAP Packet Injection",
                    attack_type=AttackType.INJECTION_ATTACK,
                    target_layer=ProtocolLayer.L2CAP,
                    complexity=AttackComplexity.COMPLEX,
                    description="Inject packets at L2CAP layer to manipulate upper protocols",
                    prerequisites=["l2cap_access", "timing_control"],
                    attack_steps=[
                        {"action": "capture_l2cap_sequence", "timing": "immediate"},
                        {"action": "analyze_packet_timing", "timing": "immediate"},
                        {"action": "craft_injection_packet", "timing": "immediate"},
                        {"action": "inject_with_precise_timing", "timing": "calculated"},
                        {"action": "verify_protocol_confusion", "timing": "post_injection"}
                    ],
                    success_indicators=["protocol_state_change", "unexpected_behavior"],
                    reliability=0.4,
                    stealth_level=4
                )
            ],
            
            AttackType.STATE_CONFUSION: [
                AttackVector(
                    name="Connection State Confusion",
                    attack_type=AttackType.STATE_CONFUSION,
                    target_layer=ProtocolLayer.GAP,
                    complexity=AttackComplexity.MODERATE,
                    description="Confuse device about connection state",
                    prerequisites=["connection_control"],
                    attack_steps=[
                        {"action": "establish_connection", "timing": "immediate"},
                        {"action": "send_conflicting_state_signals", "timing": "immediate"},
                        {"action": "race_connection_termination", "timing": "0.05s"},
                        {"action": "attempt_ghost_connection", "timing": "immediate"}
                    ],
                    success_indicators=["state_desync", "ghost_connection_active"],
                    reliability=0.5,
                    stealth_level=3
                ),
                
                AttackVector(
                    name="Security State Confusion",
                    attack_type=AttackType.STATE_CONFUSION,
                    target_layer=ProtocolLayer.SMP,
                    complexity=AttackComplexity.COMPLEX,
                    description="Desynchronize security state between devices",
                    prerequisites=["pairing_capability", "timing_precision"],
                    attack_steps=[
                        {"action": "initiate_pairing", "timing": "immediate"},
                        {"action": "send_conflicting_security_requests", "timing": "immediate"},
                        {"action": "race_security_procedures", "timing": "0.01s"},
                        {"action": "inject_fake_encryption_key", "timing": "on_key_exchange"},
                        {"action": "verify_state_desync", "timing": "post_attack"}
                    ],
                    success_indicators=["security_bypass", "cleartext_communication"],
                    reliability=0.3,
                    stealth_level=5
                )
            ],
            
            AttackType.REPLAY_ATTACK: [
                AttackVector(
                    name="ATT Transaction Replay",
                    attack_type=AttackType.REPLAY_ATTACK,
                    target_layer=ProtocolLayer.ATT,
                    complexity=AttackComplexity.SIMPLE,
                    description="Replay captured ATT transactions",
                    prerequisites=["packet_capture", "timing_flexibility"],
                    attack_steps=[
                        {"action": "capture_att_transactions", "timing": "immediate"},
                        {"action": "analyze_transaction_structure", "timing": "immediate"},
                        {"action": "replay_transactions", "timing": "delayed"},
                        {"action": "monitor_replay_effects", "timing": "post_replay"}
                    ],
                    success_indicators=["transaction_accepted", "state_change"],
                    reliability=0.7,
                    stealth_level=2
                )
            ],
            
            AttackType.RACE_CONDITION: [
                AttackVector(
                    name="Pairing Race Condition",
                    attack_type=AttackType.RACE_CONDITION,
                    target_layer=ProtocolLayer.SMP,
                    complexity=AttackComplexity.EXPERT,
                    description="Exploit race conditions in pairing procedure",
                    prerequisites=["precise_timing", "pairing_initiation"],
                    attack_steps=[
                        {"action": "initiate_pairing", "timing": "immediate"},
                        {"action": "send_rapid_conflicting_messages", "timing": "immediate"},
                        {"action": "race_pairing_confirmation", "timing": "0.001s"},
                        {"action": "exploit_timing_window", "timing": "precise"},
                        {"action": "verify_race_success", "timing": "post_race"}
                    ],
                    success_indicators=["pairing_bypass", "security_downgrade"],
                    reliability=0.2,
                    stealth_level=5
                )
            ]
        }
    
    def _initialize_protocol_constants(self) -> Dict[str, Dict[str, Any]]:
        """Initialize BLE protocol constants and opcodes"""
        
        return {
            'att_opcodes': {
                'ERROR_RSP': 0x01,
                'EXCHANGE_MTU_REQ': 0x02,
                'EXCHANGE_MTU_RSP': 0x03,
                'FIND_INFORMATION_REQ': 0x04,
                'FIND_INFORMATION_RSP': 0x05,
                'FIND_BY_TYPE_VALUE_REQ': 0x06,
                'READ_BY_TYPE_REQ': 0x08,
                'READ_REQ': 0x0A,
                'READ_RSP': 0x0B,
                'WRITE_REQ': 0x12,
                'WRITE_RSP': 0x13,
                'WRITE_CMD': 0x52,
                'PREPARE_WRITE_REQ': 0x16,
                'EXECUTE_WRITE_REQ': 0x18,
                'HANDLE_VALUE_NOTIFICATION': 0x1B,
                'HANDLE_VALUE_INDICATION': 0x1D
            },
            
            'smp_opcodes': {
                'PAIRING_REQUEST': 0x01,
                'PAIRING_RESPONSE': 0x02,
                'PAIRING_CONFIRM': 0x03,
                'PAIRING_RANDOM': 0x04,
                'PAIRING_FAILED': 0x05,
                'ENCRYPTION_INFORMATION': 0x06,
                'MASTER_IDENTIFICATION': 0x07,
                'IDENTITY_INFORMATION': 0x08,
                'IDENTITY_ADDRESS_INFORMATION': 0x09,
                'SIGNING_INFORMATION': 0x0A,
                'SECURITY_REQUEST': 0x0B,
                'PAIRING_PUBLIC_KEY': 0x0C,
                'PAIRING_DHKEY_CHECK': 0x0D,
                'PAIRING_KEYPRESS_NOTIFICATION': 0x0E
            },
            
            'gap_ad_types': {
                'FLAGS': 0x01,
                'INCOMPLETE_LIST_16BIT_SERVICE_UUIDS': 0x02,
                'COMPLETE_LIST_16BIT_SERVICE_UUIDS': 0x03,
                'SHORTENED_LOCAL_NAME': 0x08,
                'COMPLETE_LOCAL_NAME': 0x09,
                'TX_POWER_LEVEL': 0x0A,
                'MANUFACTURER_SPECIFIC_DATA': 0xFF
            },
            
            'error_codes': {
                'INVALID_HANDLE': 0x01,
                'READ_NOT_PERMITTED': 0x02,
                'WRITE_NOT_PERMITTED': 0x03,
                'INVALID_PDU': 0x04,
                'INSUFFICIENT_AUTHENTICATION': 0x05,
                'REQUEST_NOT_SUPPORTED': 0x06,
                'INVALID_OFFSET': 0x07,
                'INSUFFICIENT_AUTHORIZATION': 0x08,
                'PREPARE_QUEUE_FULL': 0x09,
                'ATTRIBUTE_NOT_FOUND': 0x0A,
                'ATTRIBUTE_NOT_LONG': 0x0B,
                'INSUFFICIENT_ENCRYPTION_KEY_SIZE': 0x0C,
                'INVALID_ATTRIBUTE_VALUE_LENGTH': 0x0D,
                'UNLIKELY_ERROR': 0x0E,
                'INSUFFICIENT_ENCRYPTION': 0x0F,
                'UNSUPPORTED_GROUP_TYPE': 0x10,
                'INSUFFICIENT_RESOURCES': 0x11
            }
        }
    
    def _initialize_state_machines(self) -> Dict[str, Dict[str, Any]]:
        """Initialize BLE protocol state machine definitions"""
        
        return {
            'pairing_state_machine': {
                'states': ['idle', 'pairing_request_sent', 'pairing_response_received', 
                          'confirm_sent', 'random_sent', 'key_distribution', 'paired'],
                'transitions': {
                    ('idle', 'pairing_request'): 'pairing_request_sent',
                    ('pairing_request_sent', 'pairing_response'): 'pairing_response_received',
                    ('pairing_response_received', 'pairing_confirm'): 'confirm_sent',
                    ('confirm_sent', 'pairing_random'): 'random_sent',
                    ('random_sent', 'encryption_info'): 'key_distribution',
                    ('key_distribution', 'key_complete'): 'paired'
                },
                'attack_points': ['pairing_request_sent', 'pairing_response_received', 'confirm_sent']
            },
            
            'connection_state_machine': {
                'states': ['disconnected', 'connecting', 'connected', 'disconnecting'],
                'transitions': {
                    ('disconnected', 'connect_request'): 'connecting',
                    ('connecting', 'connect_complete'): 'connected',
                    ('connected', 'disconnect_request'): 'disconnecting',
                    ('disconnecting', 'disconnect_complete'): 'disconnected'
                },
                'attack_points': ['connecting', 'disconnecting']
            },
            
            'security_state_machine': {
                'states': ['no_security', 'unauthenticated', 'authenticated', 'secure_connections'],
                'transitions': {
                    ('no_security', 'security_request'): 'unauthenticated',
                    ('unauthenticated', 'authentication_complete'): 'authenticated',
                    ('authenticated', 'secure_connection_setup'): 'secure_connections'
                },
                'attack_points': ['unauthenticated', 'authenticated']
            }
        }
    
    async def analyze_protocol_attack_surface(self, client: BleakClient) -> Dict[ProtocolLayer, List[str]]:
        """Analyze available protocol attack surface"""
        
        self.logger.info("Analyzing protocol attack surface")
        
        attack_surface = {layer: [] for layer in ProtocolLayer}
        
        # Update protocol state
        await self._update_protocol_state(client)
        
        # Analyze each protocol layer
        attack_surface[ProtocolLayer.GAP] = await self._analyze_gap_attack_surface(client)
        attack_surface[ProtocolLayer.L2CAP] = await self._analyze_l2cap_attack_surface(client)
        attack_surface[ProtocolLayer.ATT] = await self._analyze_att_attack_surface(client)
        attack_surface[ProtocolLayer.GATT] = await self._analyze_gatt_attack_surface(client)
        attack_surface[ProtocolLayer.SMP] = await self._analyze_smp_attack_surface(client)
        
        return attack_surface
    
    async def _update_protocol_state(self, client: BleakClient):
        """Update current protocol state information"""
        
        self.protocol_state.connection_state = "connected" if client.is_connected else "disconnected"
        self.protocol_state.last_activity = time.time()
        
        if client.is_connected:
            try:
                # Try to determine MTU
                services = client.services
                if services:
                    self.protocol_state.mtu_size = getattr(client, 'mtu_size', 23)
                
                # Check for pairing status (implementation dependent)
                self.protocol_state.pairing_state = await self._detect_pairing_state(client)
                
            except Exception as e:
                self.logger.debug(f"Protocol state update failed: {e}")
    
    async def _detect_pairing_state(self, client: BleakClient) -> str:
        """Detect current pairing/bonding state"""
        
        try:
            # Try to access a characteristic that typically requires pairing
            # This is implementation-specific
            return "unknown"
        except Exception:
            return "unpaired"
    
    async def _analyze_gap_attack_surface(self, client: BleakClient) -> List[str]:
        """Analyze GAP layer attack opportunities"""
        
        vulnerabilities = []
        
        # Check for privacy features
        if not self.protocol_state.encryption_enabled:
            vulnerabilities.append("no_privacy_enabled")
        
        # Check connection parameters
        if self.protocol_state.connection_interval == 0:
            vulnerabilities.append("connection_parameter_manipulation")
        
        # Check for advertising vulnerabilities (would need additional scanning)
        vulnerabilities.append("advertising_analysis_required")
        
        return vulnerabilities
    
    async def _analyze_l2cap_attack_surface(self, client: BleakClient) -> List[str]:
        """Analyze L2CAP layer attack opportunities"""
        
        vulnerabilities = []
        
        # Check MTU handling
        if self.protocol_state.mtu_size < 23:
            vulnerabilities.append("invalid_mtu_size")
        elif self.protocol_state.mtu_size > 512:
            vulnerabilities.append("oversized_mtu_potential")
        
        # Check for L2CAP credit-based flow control
        vulnerabilities.append("l2cap_flow_control_testing")
        
        return vulnerabilities
    
    async def _analyze_att_attack_surface(self, client: BleakClient) -> List[str]:
        """Analyze ATT layer attack opportunities"""
        
        vulnerabilities = []
        
        try:
            services = client.services
            
            # Count writable characteristics without authentication
            writable_unauth = 0
            total_writable = 0
            
            for service in services:
                for char in service.characteristics:
                    if "write" in char.properties or "write-without-response" in char.properties:
                        total_writable += 1
                        # This would need deeper analysis to determine auth requirements
                        writable_unauth += 1
            
            if writable_unauth > 0:
                vulnerabilities.append(f"unauthenticated_write_access_{writable_unauth}")
            
            if total_writable > 10:
                vulnerabilities.append("excessive_write_surface")
            
            # Check for ATT error handling
            vulnerabilities.append("att_error_handling_analysis")
            
        except Exception as e:
            vulnerabilities.append(f"att_enumeration_failed_{str(e)[:20]}")
        
        return vulnerabilities
    
    async def _analyze_gatt_attack_surface(self, client: BleakClient) -> List[str]:
        """Analyze GATT layer attack opportunities"""
        
        vulnerabilities = []
        
        try:
            services = client.services
            
            # Check service hierarchy
            custom_services = 0
            standard_services = 0
            
            for service in services:
                if len(str(service.uuid)) == 36:  # 128-bit UUID (custom)
                    custom_services += 1
                else:
                    standard_services += 1
            
            if custom_services > standard_services:
                vulnerabilities.append("custom_service_heavy")
            
            # Check for service discovery anomalies
            if len(services) > 20:
                vulnerabilities.append("excessive_service_exposure")
            
            # Check for GATT caching issues
            vulnerabilities.append("gatt_caching_analysis")
            
        except Exception as e:
            vulnerabilities.append(f"gatt_analysis_failed_{str(e)[:20]}")
        
        return vulnerabilities
    
    async def _analyze_smp_attack_surface(self, client: BleakClient) -> List[str]:
        """Analyze SMP (Security Manager Protocol) attack opportunities"""
        
        vulnerabilities = []
        
        # Check pairing state
        if self.protocol_state.pairing_state == "unpaired":
            vulnerabilities.append("pairing_attack_surface")
            vulnerabilities.append("just_works_downgrade_possible")
        
        # Check encryption status
        if not self.protocol_state.encryption_enabled:
            vulnerabilities.append("no_encryption_active")
            vulnerabilities.append("cleartext_communication")
        
        # Check security level
        if self.protocol_state.security_level < 3:
            vulnerabilities.append("insufficient_security_level")
        
        return vulnerabilities
    
    async def execute_protocol_attack(self, client: BleakClient, 
                                    attack_vector: AttackVector) -> AttackResult:
        """Execute a specific protocol attack vector"""
        
        self.logger.info(f"Executing {attack_vector.name}")
        
        start_time = time.time()
        attack_id = f"attack_{int(time.time())}"
        self.active_attacks[attack_id] = attack_vector
        
        # Verify prerequisites
        prereq_check = await self._verify_prerequisites(client, attack_vector)
        if not prereq_check:
            return AttackResult(
                attack_name=attack_vector.name,
                attack_type=attack_vector.attack_type,
                success=False,
                target_layer=attack_vector.target_layer,
                execution_time=time.time() - start_time,
                steps_completed=0,
                total_steps=len(attack_vector.attack_steps),
                error_message="Prerequisites not met"
            )
        
        # Execute attack steps
        steps_completed = 0
        privileges_gained = []
        data_extracted = {}
        side_effects = []
        
        try:
            for i, step in enumerate(attack_vector.attack_steps):
                self.logger.debug(f"Executing step {i+1}: {step['action']}")
                
                step_success = await self._execute_attack_step(client, step, attack_vector)
                
                if step_success:
                    steps_completed += 1
                    
                    # Check for immediate effects
                    effects = await self._analyze_step_effects(client, step, attack_vector)
                    privileges_gained.extend(effects.get('privileges', []))
                    data_extracted.update(effects.get('data', {}))
                    side_effects.extend(effects.get('side_effects', []))
                else:
                    self.logger.warning(f"Attack step {i+1} failed: {step['action']}")
                    break
            
            # Verify overall attack success
            success = await self._verify_attack_success(client, attack_vector, steps_completed)
            
            execution_time = time.time() - start_time
            
            result = AttackResult(
                attack_name=attack_vector.name,
                attack_type=attack_vector.attack_type,
                success=success,
                target_layer=attack_vector.target_layer,
                execution_time=execution_time,
                steps_completed=steps_completed,
                total_steps=len(attack_vector.attack_steps),
                privileges_gained=privileges_gained,
                data_extracted=data_extracted,
                side_effects=side_effects,
                detection_likelihood=self._assess_detection_likelihood(attack_vector, steps_completed)
            )
            
            # Cleanup
            if attack_id in self.active_attacks:
                del self.active_attacks[attack_id]
            
            self.attack_history.append(result)
            
            return result
            
        except Exception as e:
            execution_time = time.time() - start_time
            
            if attack_id in self.active_attacks:
                del self.active_attacks[attack_id]
            
            return AttackResult(
                attack_name=attack_vector.name,
                attack_type=attack_vector.attack_type,
                success=False,
                target_layer=attack_vector.target_layer,
                execution_time=execution_time,
                steps_completed=steps_completed,
                total_steps=len(attack_vector.attack_steps),
                error_message=str(e)
            )
    
    async def _verify_prerequisites(self, client: BleakClient, 
                                  attack_vector: AttackVector) -> bool:
        """Verify attack prerequisites are met"""
        
        for prereq in attack_vector.prerequisites:
            if prereq == "unpaired_device":
                if self.protocol_state.pairing_state != "unpaired":
                    return False
            elif prereq == "connected_device":
                if not client.is_connected:
                    return False
            elif prereq == "writable_characteristics":
                if not await self._has_writable_characteristics(client):
                    return False
            # Add more prerequisite checks as needed
        
        return True
    
    async def _has_writable_characteristics(self, client: BleakClient) -> bool:
        """Check if device has writable characteristics"""
        
        try:
            services = client.services
            for service in services:
                for char in service.characteristics:
                    if "write" in char.properties or "write-without-response" in char.properties:
                        return True
            return False
        except Exception:
            return False
    
    async def _execute_attack_step(self, client: BleakClient, 
                                 step: Dict[str, Any], 
                                 attack_vector: AttackVector) -> bool:
        """Execute individual attack step"""
        
        action = step['action']
        timing = step.get('timing', 'immediate')
        params = step.get('params', {})
        
        # Handle timing
        if timing != 'immediate':
            if timing.endswith('s'):
                delay = float(timing[:-1])
                await asyncio.sleep(delay)
            elif timing == 'on_pairing_response':
                # Would need to wait for specific protocol events
                await asyncio.sleep(0.1)  # Placeholder
        
        # Execute action based on type
        try:
            if action == "intercept_pairing_request":
                return await self._intercept_pairing_request(client, params)
            elif action == "modify_io_capabilities":
                return await self._modify_io_capabilities(client, params)
            elif action == "send_conflicting_pairing_response":
                return await self._send_conflicting_pairing_response(client, params)
            elif action == "enumerate_characteristics":
                return await self._enumerate_characteristics(client, params)
            elif action == "test_direct_access":
                return await self._test_direct_access(client, params)
            elif action == "send_unauthenticated_write":
                return await self._send_unauthenticated_write(client, params)
            elif action == "craft_injection_payload":
                return await self._craft_injection_payload(client, params)
            elif action == "inject_during_operation":
                return await self._inject_during_operation(client, params)
            elif action == "establish_connection":
                return client.is_connected
            elif action == "send_conflicting_state_signals":
                return await self._send_conflicting_state_signals(client, params)
            else:
                self.logger.warning(f"Unknown attack action: {action}")
                return False
                
        except Exception as e:
            self.logger.error(f"Attack step '{action}' failed: {e}")
            return False
    
    # Attack action implementations
    async def _intercept_pairing_request(self, client: BleakClient, params: Dict[str, Any]) -> bool:
        """Intercept and potentially modify pairing request"""
        # This would require low-level BLE stack access
        # Implementation would be platform-specific
        self.logger.debug("Simulating pairing request interception")
        return True
    
    async def _modify_io_capabilities(self, client: BleakClient, params: Dict[str, Any]) -> bool:
        """Modify IO capabilities for pairing downgrade"""
        # This would require SMP-level access
        io_cap = params.get('io_cap', 0x03)  # NoInputNoOutput
        self.logger.debug(f"Simulating IO capability modification to {io_cap}")
        return True
    
    async def _send_conflicting_pairing_response(self, client: BleakClient, params: Dict[str, Any]) -> bool:
        """Send conflicting pairing response to confuse state machine"""
        # This would require crafting SMP packets
        self.logger.debug("Simulating conflicting pairing response")
        return True
    
    async def _enumerate_characteristics(self, client: BleakClient, params: Dict[str, Any]) -> bool:
        """Enumerate characteristics for attack planning"""
        try:
            services = client.services
            char_count = sum(len(service.characteristics) for service in services)
            self.logger.debug(f"Enumerated {char_count} characteristics")
            return char_count > 0
        except Exception:
            return False
    
    async def _test_direct_access(self, client: BleakClient, params: Dict[str, Any]) -> bool:
        """Test direct access to protected characteristics"""
        try:
            services = client.services
            for service in services:
                for char in service.characteristics:
                    if "read" in char.properties:
                        try:
                            await client.read_gatt_char(char.uuid)
                            return True
                        except Exception:
                            continue
            return False
        except Exception:
            return False
    
    async def _send_unauthenticated_write(self, client: BleakClient, params: Dict[str, Any]) -> bool:
        """Attempt unauthenticated write to protected characteristic"""
        try:
            services = client.services
            for service in services:
                for char in service.characteristics:
                    if "write" in char.properties or "write-without-response" in char.properties:
                        try:
                            test_data = params.get('test_data', b'\x41\x41\x41\x41')
                            await client.write_gatt_char(char.uuid, test_data, response=False)
                            return True
                        except Exception:
                            continue
            return False
        except Exception:
            return False
    
    async def _craft_injection_payload(self, client: BleakClient, params: Dict[str, Any]) -> bool:
        """Craft protocol injection payload"""
        # This would create specific protocol packets for injection
        self.logger.debug("Crafting injection payload")
        return True
    
    async def _inject_during_operation(self, client: BleakClient, params: Dict[str, Any]) -> bool:
        """Inject payload during normal protocol operation"""
        # This would require precise timing and low-level access
        self.logger.debug("Simulating protocol injection")
        return True
    
    async def _send_conflicting_state_signals(self, client: BleakClient, params: Dict[str, Any]) -> bool:
        """Send conflicting state signals to confuse device"""
        # This would send contradictory protocol messages
        self.logger.debug("Sending conflicting state signals")
        return True
    
    async def _analyze_step_effects(self, client: BleakClient, 
                                  step: Dict[str, Any], 
                                  attack_vector: AttackVector) -> Dict[str, Any]:
        """Analyze effects of completed attack step"""
        
        effects = {
            'privileges': [],
            'data': {},
            'side_effects': []
        }
        
        # Check for privilege escalation
        if step['action'] in ['send_unauthenticated_write', 'test_direct_access']:
            if await self._test_elevated_access(client):
                effects['privileges'].append('write_access_gained')
        
        # Check for data extraction opportunities
        if step['action'] == 'enumerate_characteristics':
            char_data = await self._extract_characteristic_data(client)
            effects['data']['characteristics'] = char_data
        
        # Check for side effects
        if not client.is_connected:
            effects['side_effects'].append('device_disconnected')
        
        return effects
    
    async def _test_elevated_access(self, client: BleakClient) -> bool:
        """Test if elevated access was gained"""
        try:
            # This would test access to previously restricted resources
            return False
        except Exception:
            return False
    
    async def _extract_characteristic_data(self, client: BleakClient) -> Dict[str, Any]:
        """Extract characteristic information"""
        char_data = {}
        
        try:
            services = client.services
            for service in services:
                service_data = {
                    'uuid': str(service.uuid),
                    'characteristics': []
                }
                
                for char in service.characteristics:
                    char_info = {
                        'uuid': str(char.uuid),
                        'properties': char.properties,
                        'handle': char.handle
                    }
                    service_data['characteristics'].append(char_info)
                
                char_data[str(service.uuid)] = service_data
        
        except Exception:
            pass
        
        return char_data
    
    async def _verify_attack_success(self, client: BleakClient, 
                                   attack_vector: AttackVector, 
                                   steps_completed: int) -> bool:
        """Verify if attack achieved its objectives"""
        
        # Check success indicators
        for indicator in attack_vector.success_indicators:
            if indicator == "pairing_complete":
                if await self._check_pairing_complete(client):
                    return True
            elif indicator == "no_authentication_required":
                if await self._check_no_auth_required(client):
                    return True
            elif indicator == "write_success":
                if await self._check_write_success(client):
                    return True
            elif indicator == "privilege_escalation":
                if await self._check_privilege_escalation(client):
                    return True
        
        # Fallback: success if most steps completed
        success_threshold = 0.7
        return (steps_completed / len(attack_vector.attack_steps)) >= success_threshold
    
    async def _check_pairing_complete(self, client: BleakClient) -> bool:
        """Check if pairing completed successfully"""
        # Implementation would check actual pairing status
        return False
    
    async def _check_no_auth_required(self, client: BleakClient) -> bool:
        """Check if authentication is no longer required"""
        # Implementation would test access to previously protected resources
        return False
    
    async def _check_write_success(self, client: BleakClient) -> bool:
        """Check if write operations are succeeding"""
        return await self._test_elevated_access(client)
    
    async def _check_privilege_escalation(self, client: BleakClient) -> bool:
        """Check if privilege escalation occurred"""
        return await self._test_elevated_access(client)
    
    def _assess_detection_likelihood(self, attack_vector: AttackVector, 
                                   steps_completed: int) -> str:
        """Assess likelihood of attack detection"""
        
        base_detection = attack_vector.stealth_level
        completion_factor = steps_completed / len(attack_vector.attack_steps)
        
        # Higher stealth level = lower detection likelihood
        # More steps completed = higher detection likelihood
        detection_score = (6 - base_detection) + (completion_factor * 3)
        
        if detection_score <= 2:
            return "very_low"
        elif detection_score <= 4:
            return "low"
        elif detection_score <= 6:
            return "medium"
        elif detection_score <= 8:
            return "high"
        else:
            return "very_high"
    
    def get_recommended_attacks(self, attack_surface: Dict[ProtocolLayer, List[str]]) -> List[AttackVector]:
        """Get recommended attacks based on attack surface analysis"""
        
        recommended = []
        
        # Analyze attack surface and recommend appropriate vectors
        for layer, vulnerabilities in attack_surface.items():
            layer_attacks = []
            
            for attack_type, vectors in self.attack_vectors.items():
                for vector in vectors:
                    if vector.target_layer == layer:
                        # Check if attack is relevant to discovered vulnerabilities
                        if self._is_attack_relevant(vector, vulnerabilities):
                            layer_attacks.append(vector)
            
            # Sort by reliability and add top attacks
            layer_attacks.sort(key=lambda x: x.reliability, reverse=True)
            recommended.extend(layer_attacks[:2])  # Top 2 per layer
        
        return recommended
    
    def _is_attack_relevant(self, attack_vector: AttackVector, 
                          vulnerabilities: List[str]) -> bool:
        """Check if attack vector is relevant to discovered vulnerabilities"""
        
        # Simple relevance checking based on vulnerability keywords
        attack_keywords = {
            AttackType.AUTHENTICATION_BYPASS: ['unauthenticated', 'auth', 'permission'],
            AttackType.PAIRING_BYPASS: ['pairing', 'unpaired', 'security'],
            AttackType.INJECTION_ATTACK: ['write', 'injection', 'command'],
            AttackType.STATE_CONFUSION: ['state', 'confusion', 'flow'],
        }
        
        keywords = attack_keywords.get(attack_vector.attack_type, [])
        
        for vuln in vulnerabilities:
            for keyword in keywords:
                if keyword in vuln.lower():
                    return True
        
        return True  # Default to relevant for comprehensive testing
    
    def generate_attack_report(self, attack_results: List[AttackResult]) -> str:
        """Generate comprehensive protocol attack report"""
        
        successful_attacks = [r for r in attack_results if r.success]
        privilege_escalations = [r for r in attack_results if r.privileges_gained]
        
        report = f"""
ðŸŽ¯ PROTOCOL ATTACK ANALYSIS REPORT
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ“Š ATTACK SUMMARY:
â€¢ Total attacks attempted: {len(attack_results)}
â€¢ Successful attacks: {len(successful_attacks)}
â€¢ Privilege escalations: {len(privilege_escalations)}
â€¢ Detection likelihood: {self._calculate_overall_detection(attack_results)}

"""
        
        if successful_attacks:
            report += "ðŸŽ¯ SUCCESSFUL ATTACKS:\n"
            for result in successful_attacks:
                report += f"  âœ“ {result.attack_name}\n"
                report += f"    Type: {result.attack_type.value.upper()}\n"
                report += f"    Layer: {result.target_layer.value.upper()}\n"
                report += f"    Execution time: {result.execution_time:.2f}s\n"
                report += f"    Steps completed: {result.steps_completed}/{result.total_steps}\n"
                
                if result.privileges_gained:
                    report += f"    Privileges gained: {', '.join(result.privileges_gained)}\n"
                
                if result.side_effects:
                    report += f"    Side effects: {', '.join(result.side_effects)}\n"
                
                report += f"    Detection likelihood: {result.detection_likelihood}\n\n"
        
        # Attack surface analysis
        if hasattr(self, 'last_attack_surface'):
            report += "ðŸ” PROTOCOL LAYER ANALYSIS:\n"
            for layer, vulns in self.last_attack_surface.items():
                if vulns:
                    report += f"  {layer.value.upper()}: {len(vulns)} vulnerabilities\n"
                    for vuln in vulns[:3]:  # Show top 3
                        report += f"    â€¢ {vuln}\n"
        
        # Recommendations
        report += "\nðŸ’¡ PROTOCOL SECURITY RECOMMENDATIONS:\n"
        
        attack_types_seen = set(r.attack_type for r in successful_attacks)
        
        if AttackType.AUTHENTICATION_BYPASS in attack_types_seen:
            report += "  â€¢ Implement proper authentication checks at all protocol layers\n"
        
        if AttackType.PAIRING_BYPASS in attack_types_seen:
            report += "  â€¢ Enforce secure pairing methods and prevent downgrade attacks\n"
        
        if AttackType.INJECTION_ATTACK in attack_types_seen:
            report += "  â€¢ Validate all protocol inputs and implement proper state machines\n"
        
        if AttackType.STATE_CONFUSION in attack_types_seen:
            report += "  â€¢ Implement robust state synchronization and validation\n"
        
        return report
    
    def _calculate_overall_detection(self, attack_results: List[AttackResult]) -> str:
        """Calculate overall detection likelihood"""
        
        if not attack_results:
            return "unknown"
        
        detection_scores = {
            "very_low": 1, "low": 2, "medium": 3, "high": 4, "very_high": 5
        }
        
        total_score = 0
        for result in attack_results:
            if result.success:
                score = detection_scores.get(result.detection_likelihood, 3)
                total_score += score
        
        if not any(r.success for r in attack_results):
            return "n/a"
        
        avg_score = total_score / len([r for r in attack_results if r.success])
        
        if avg_score <= 1.5:
            return "very_low"
        elif avg_score <= 2.5:
            return "low"
        elif avg_score <= 3.5:
            return "medium"
        elif avg_score <= 4.5:
            return "high"
        else:
            return "very_high"


# Factory function for easy usage
def create_protocol_attack_engine() -> ProtocolAttackEngine:
    """Create protocol attack engine"""
    return ProtocolAttackEngine()